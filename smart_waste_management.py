# -*- coding: utf-8 -*-
"""smart_waste_management.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12TpIk2Oc5PuuPKxCdfd1fVcLdjVJ8UUJ
"""

import cv2

# The following code is for opencv-fr-sdk, which is not installed.
# from opencv.fr import FR
# from opencv.fr.persons.schemas import PersonBase
# from opencv.fr.search.schemas import SearchRequest
# sdk=FR(backend_url="https://us.opencv.fr",developer_key="DEV_KEY")
# person=PersonBase(images=["/path/to/img.png"],name="PersonName")
# person=sdk.persons.create(person)
# search_request=SearchRequest(["/path/to/test_img.png"])
# result=sdk.search.search(search_request)
# print(result)

# Please add your opencv-python code here.



!pip install opencv-fr-sdk

pip install cv2

!pip install opencv-python tensorflow fastapi uvicorn streamlit kaggle matplotlib

from google.colab import files
files.upload()
!mkdir ~/ .kaggle
!cp kaggle.json ~/ .kaggle/
!chmod 600 ~/ .kaggle/kaggle.json
!kaggle datasets download -d asdasdasasdas/garbage-classification
!unzip garbage-classification.zip -d garbage_data

import random
import time
import csv

def simulate_sensor():
    while True:
        distance = random.randint(2, 30)  # 2 = full, 30 = empty
        with open('data.csv', 'a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([time.strftime('%Y-%m-%d %H:%M:%S'), distance])
        time.sleep(5)  # every 5 seconds

# Smart waste management using kaggle API
!pip install -q kaggle

from google.colab import files
files.upload()  # Upload kaggle.json here

import os
os.makedirs("/root/.kaggle", exist_ok=True)
!mv kaggle.json /root/.kaggle/
!chmod 600 /root/.kaggle/kaggle.json

!kaggle datasets download -d shubhendra7/garbage-level-detection
!unzip -q garbage-level-detection.zip

import pandas as pd

df = pd.read_csv('garbage_level.csv')  # adjust name if different
df.head()

import matplotlib.pyplot as plt
import seaborn as sns

# Clean column names if needed
df.columns = [col.strip() for col in df.columns]

# Plot garbage level over time
plt.figure(figsize=(12, 6))
sns.lineplot(data=df, x='Timestamp', y='Garbage_Level')
plt.xticks(rotation=45)
plt.title("Garbage Level Over Time")
plt.xlabel("Time")
plt.ylabel("Garbage Level (%)")
plt.grid(True)
plt.tight_layout()
plt.show()

def classify_status(level):
    if level >= 80:
        return "🔴 Full"
    elif level >= 40:
        return "🟡 Half Full"
    else:
        return "🟢 Empty"

df['Status'] = df['Garbage_Level'].apply(classify_status)
df[['Timestamp', 'Garbage_Level', 'Status']].tail(10)



#smart waste management system without using kaggle
import pandas as pd
import random
import time

# Simulate timestamps for the past 50 minutes
timestamps = pd.date_range(end=pd.Timestamp.now(), periods=50, freq='1min')

# Simulate distance values (2 cm = full, 30 cm = empty)
distances = [random.randint(2, 30) for _ in range(50)]

# Create DataFrame
df = pd.DataFrame({
    "Timestamp": timestamps,
    "Distance (cm)": distances
})

df.head()



def classify_bin(distance):
    if distance <= 5:
        return "🔴 Full"
    elif distance <= 15:
        return "🟡 Half Full"
    else:
        return "🟢 Empty"

df["Status"] = df["Distance (cm)"].apply(classify_bin)
df.head()

df.to_csv("simulated_waste_data.csv", index=False)

from google.colab import files
files.download("simulated_waste_data.csv")

import pandas as pd
import matplotlib.pyplot as plt

# Load the dataset
df = pd.read_csv("simulated_waste_data.csv")
df["Timestamp"] = pd.to_datetime(df["Timestamp"])

# Plot
plt.figure(figsize=(12, 6))
plt.plot(df["Timestamp"], df["Distance (cm)"], marker='o', color='green')
plt.title("Waste Bin Fill Level Over Time")
plt.xlabel("Time")
plt.ylabel("Distance from Top (cm)")
plt.xticks(rotation=45)
plt.grid(True)
plt.tight_layout()
plt.show()

full_bins = df[df["Distance (cm)"] <= 5]

if not full_bins.empty:
    print("🚨 ALERT: Bin is Full!")
else:
    print("✅ Bin status normal.")

from sklearn.linear_model import LinearRegression
import numpy as np

# Convert Timestamp to elapsed time (minutes)
df["Time_Minutes"] = (df["Timestamp"] - df["Timestamp"].min()).dt.total_seconds() / 60

# Reshape for sklearn
X = df["Time_Minutes"].values.reshape(-1, 1)
y = df["Distance (cm)"].values.reshape(-1, 1)

model = LinearRegression()
model.fit(X, y)

# Predict time when bin will be <= 5 cm (full)
predicted_time = (5 - model.intercept_[0]) / model.coef_[0][0]

print(f"⏳ Predicted time for full bin: {predicted_time:.2f} minutes from start")

from sklearn.linear_model import LinearRegression
import numpy as np

# Load and prepare data
df = pd.read_csv("simulated_waste_data.csv")
df["Timestamp"] = pd.to_datetime(df["Timestamp"])
df["Elapsed_Min"] = (df["Timestamp"] - df["Timestamp"].min()).dt.total_seconds() / 60

# Train model
X = df["Elapsed_Min"].values.reshape(-1, 1)
y = df["Distance (cm)"].values.reshape(-1, 1)

model = LinearRegression()
model.fit(X, y)

# Predict time when bin reaches 5 cm
predicted_min = (5 - model.intercept_[0]) / model.coef_[0][0]
print(f"🧠 Predicted time for FULL BIN: {predicted_min:.2f} minutes after start")

full_bins = df[df["Distance (cm)"] <= 5]
if not full_bins.empty:
    print("🚨 ALERT: Bin is Full!")
else:
    print("✅ Bin Status: Normal")